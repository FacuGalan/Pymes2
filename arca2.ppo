#line 203 "c:\harb16\include\hbclass.ch"
DECLARE HBClass  New( cName AS STRING, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS OBJECT  Instance() AS OBJECT  AddClsMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC, n2 AS NUMERIC, n3 AS NUMERIC )  AddMultiClsData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING )  AddMultiData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC )  AddInLine( cName AS STRING, bBlock AS CODEBLOCK, nScope AS NUMERIC )  AddVirtual( cName AS STRING )
#line 91 "C:\FWH16\INCLUDE\FiveWin.ch"
         EXTERNAL FW_GT
















extern errorsys











































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 63 "arca2.prg"
_HB_CLASS WSAFip ; function WSAFip ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "WSAFip", iif( .F., { }, { @HBObject() } ), @WSAFip() ) ) ;

; _HB_MEMBER { cToken } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cToken"}, .F. )
; _HB_MEMBER { cSign } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSign"}, .F. )
; _HB_MEMBER { cCuitRepresentada } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cCuitRepresentada"}, .F. )
; _HB_MEMBER { dTokenExpiry } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"dTokenExpiry"}, .F. )
; _HB_MEMBER { cTokenTimeExpiry } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTokenTimeExpiry"}, .F. )

; _HB_MEMBER { cLastError } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cLastError"}, .F. )
; _HB_MEMBER { nLastCode } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLastCode"}, .F. )
; _HB_MEMBER { aErrors } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aErrors"}, .F. )
; _HB_MEMBER { aObservaciones } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aObservaciones"}, .F. )

; _HB_MEMBER { cUrlWsaa } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cUrlWsaa"}, .F. )
; _HB_MEMBER { cUrlWsfe } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cUrlWsfe"}, .F. )

; _HB_MEMBER { cPathOpenSSL } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPathOpenSSL"}, .F. )

; _HB_MEMBER { cCAE } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cCAE"}, .F. )
; _HB_MEMBER { dCAEVto } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"dCAEVto"}, .F. )
; _HB_MEMBER { cResultado } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cResultado"}, .F. )

; _HB_MEMBER { aCabeceraFE } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aCabeceraFE"}, .F. )
; _HB_MEMBER { aDetallesFE } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aDetallesFE"}, .F. )
; _HB_MEMBER { aIvaItems } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aIvaItems"}, .F. )
; _HB_MEMBER { aTributos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aTributos"}, .F. )
; _HB_MEMBER { aCompAsociados } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aCompAsociados"}, .F. )
; _HB_MEMBER { aActividades } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aActividades"}, .F. )
; _HB_MEMBER { aOpcionales } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aOpcionales"}, .F. )
; _HB_MEMBER { cLogFile } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cLogFile"}, .F. )
; _HB_MEMBER { lLogWrite } ; oClass:AddMultiData(, .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lLogWrite"}, .F. )



   _HB_MEMBER New( cCuit, lTestMode); oClass:AddMethod( "New", @WSAFip_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Login( cCertFile, cPrivKeyFile, cService); oClass:AddMethod( "Login", @WSAFip_Login(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SFRecuperaLastCMP( nPuntoVta, nTipoComp); oClass:AddMethod( "SFRecuperaLastCMP", @WSAFip_SFRecuperaLastCMP(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Reset(); oClass:AddMethod( "Reset", @WSAFip_Reset(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AgregaFactura( nTipoFac, nTipoDoc, nNroDoc, nFacturaNro, nTotal, nNoGrav, nNeto, nExento, dFecDes, dFecHas, dFchVto, cMoneda, nCotiza, nConcepto); oClass:AddMethod( "AgregaFactura", @WSAFip_AgregaFactura(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AgregaCompAsoc( nTipoComp, nPuntoVta, nComprAsoc, cCuit, dFechaComp); oClass:AddMethod( "AgregaCompAsoc", @WSAFip_AgregaCompAsoc(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AgregaIVA( nTasa, nNeto, nIva); oClass:AddMethod( "AgregaIVA", @WSAFip_AgregaIVA(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AgregaTributo( nCodigo, cDetalle, nBaseImp, nCoef, nImporte); oClass:AddMethod( "AgregaTributo", @WSAFip_AgregaTributo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AgregaActividad( nCodigo); oClass:AddMethod( "AgregaActividad", @WSAFip_AgregaActividad(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER agregaOpcional( cCodigo,cDetale); oClass:AddMethod( "agregaOpcional", @WSAFip_agregaOpcional(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Autorizar( nPuntoVta, nTipoComp); oClass:AddMethod( "Autorizar", @WSAFip_Autorizar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER BuscarTAExistente( cService); oClass:AddMethod( "BuscarTAExistente", @WSAFip_BuscarTAExistente(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ConsultaCAE( nPuntoVta, nTipoComp, nNumComp); oClass:AddMethod( "ConsultaCAE", @WSAFip_ConsultaCAE(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetTiposComprobantes(); oClass:AddMethod( "GetTiposComprobantes", @WSAFip_GetTiposComprobantes(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetTiposDocumentos(); oClass:AddMethod( "GetTiposDocumentos", @WSAFip_GetTiposDocumentos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetTiposIva(); oClass:AddMethod( "GetTiposIva", @WSAFip_GetTiposIva(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetTiposMonedas(); oClass:AddMethod( "GetTiposMonedas", @WSAFip_GetTiposMonedas(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetTiposTributos(); oClass:AddMethod( "GetTiposTributos", @WSAFip_GetTiposTributos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetPuntosVenta(); oClass:AddMethod( "GetPuntosVenta", @WSAFip_GetPuntosVenta(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetActividades(); oClass:AddMethod( "GetActividades", @WSAFip_GetActividades(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetCondicionesIvaReceptor( cClaseComp); oClass:AddMethod( "GetCondicionesIvaReceptor", @WSAFip_GetCondicionesIvaReceptor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER GetLastError(); oClass:AddMethod( "GetLastError", @WSAFip_GetLastError(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetLastErrorCode(); oClass:AddMethod( "GetLastErrorCode", @WSAFip_GetLastErrorCode(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetCAE(); oClass:AddMethod( "GetCAE", @WSAFip_GetCAE(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetCAEVto(); oClass:AddMethod( "GetCAEVto", @WSAFip_GetCAEVto(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetResultado(); oClass:AddMethod( "GetResultado", @WSAFip_GetResultado(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER WriteLog( cMsg); oClass:AddMethod( "WriteLog", @WSAFip_WriteLog(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER CheckTAExpired(); oClass:AddMethod( "CheckTAExpired", @WSAFip_CheckTAExpired(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GenerarTRA( cService); oClass:AddMethod( "GenerarTRA", @WSAFip_GenerarTRA(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetAFIPServerTime(); oClass:AddMethod( "GetAFIPServerTime", @WSAFip_GetAFIPServerTime(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER FirmarTRA( cTRA, cCertFile, cPrivKeyFile); oClass:AddMethod( "FirmarTRA", @WSAFip_FirmarTRA(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EnviarTRA( cTraFirmadoBase64); oClass:AddMethod( "EnviarTRA", @WSAFip_EnviarTRA(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ParseLoginTicketResponse( cResponse); oClass:AddMethod( "ParseLoginTicketResponse", @WSAFip_ParseLoginTicketResponse(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GenerarXMLCAESolicitar(); oClass:AddMethod( "GenerarXMLCAESolicitar", @WSAFip_GenerarXMLCAESolicitar(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ParseFECAESolicitarResponse( cResponse); oClass:AddMethod( "ParseFECAESolicitarResponse", @WSAFip_ParseFECAESolicitarResponse(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SendRequest( cURL, cAction, cXML); oClass:AddMethod( "SendRequest", @WSAFip_SendRequest(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Base64Encode1( cData); oClass:AddMethod( "Base64Encode1", @WSAFip_Base64Encode1(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Base64Decode1( cData); oClass:AddMethod( "Base64Decode1", @WSAFip_Base64Decode1(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER XMLEncode( cData); oClass:AddMethod( "XMLEncode", @WSAFip_XMLEncode(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DateToWSDate( dDate); oClass:AddMethod( "DateToWSDate", @WSAFip_DateToWSDate(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS WSAFip ;






static FUNCTION WSAFip_New( cCuit, lTestMode ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cHomoUrl := "https://wswhomo.afip.gov.ar/"
   LOCAL cProdUrl := "https://servicios1.afip.gov.ar/"

   ::cCuitRepresentada := cCuit
   ::cToken := ""
   ::cSign := ""
   ::dTokenExpiry := CTOD("")
   ::cTokenTimeExpiry := "00:00:00"

   ::cLastError := ""
   ::nLastCode := 0
   ::aErrors := {}
   ::aObservaciones := {}

   ::cCAE := ""
   ::dCAEVto := CTOD("")
   ::cResultado := ""

   ::cPathOpenSSL := ".\DRIVERSFC"

   IF lTestMode
      ::cUrlWsaa := "https://wsaahomo.afip.gov.ar/ws/services/LoginCms"
      ::cUrlWsfe := "https://wswhomo.afip.gov.ar/wsfev1/service.asmx"
   ELSE
      ::cUrlWsaa := "https://wsaa.afip.gov.ar/ws/services/LoginCms"
      ::cUrlWsfe := "https://servicios1.afip.gov.ar/wsfev1/service.asmx"
   ENDIF

   ::aCabeceraFE := {0, 0, 0}
   ::aDetallesFE := {}
   ::aIvaItems := {}
   ::aTributos := {}
   ::aCompAsociados := {}
   ::aActividades := {}
   ::aOpcionales := {}

   ::cLogFile := "wsafip_" + ::cCuitRepresentada + ".log"

RETURN SELF








static FUNCTION WSAFip_Login( cCertFile, cPrivKeyFile, cService ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cLoginTicketResponse, cTA, cTra, cTraFirmado, cTraFirmadoBase64
   LOCAL lSuccess := .F., cExpiration, cExpYear, cExpMonth, cExpDay, cExpTime
   LOCAL cTAFilename := "TA_" + cService +::cCuitRepresentada+ ".xml"


   IF FILE(cTAFilename)
      ::WriteLog("Encontrado archivo TA local: " + cTAFilename)
      cTA := MemoRead(cTAFilename)


      IF !EMPTY(cTA)
         IF AT("<token>", cTA) > 0
            ::cToken := SUBSTR(cTA, AT("<token>", cTA) + 7, AT("</token>", cTA) - AT("<token>", cTA) - 7)
         ENDIF

         IF AT("<sign>", cTA) > 0
            ::cSign := SUBSTR(cTA, AT("<sign>", cTA) + 6, AT("</sign>", cTA) - AT("<sign>", cTA) - 6)
         ENDIF

         IF AT("<expirationTime>", cTA) > 0
            cExpiration := SUBSTR(cTA, AT("<expirationTime>", cTA) + 16, AT("</expirationTime>", cTA) - AT("<expirationTime>", cTA) - 16)
            ::WriteLog("cExpiration: " + cExpiration)

            cExpYear := LEFT(cExpiration, 4)
            cExpMonth := SUBSTR(cExpiration, 6, 2)
            cExpDay := SUBSTR(cExpiration, 9, 2)
            cExpTime := SUBSTR(cExpiration, 12, 8)


            ::dTokenExpiry := CTOD(cExpDay + "/" + cExpMonth + "/" + cExpYear)
            ::cTokenTimeExpiry := cExpTime
         ENDIF
      ENDIF

      ::WriteLog("dTokenExpiry: " + DTOC(::dTokenExpiry) +  " " + ::cTokenTimeExpiry)


      IF !EMPTY(::cToken) .AND. !EMPTY(::cSign) .AND. !EMPTY(::dTokenExpiry)
         IF ::dTokenExpiry > DATE() .OR. (::dTokenExpiry = DATE() .AND. ::cTokenTimeExpiry > TIME())
            ::WriteLog("TA local válido encontrado. Expira: " + DTOC(::dTokenExpiry)+" "+::cTokenTimeExpiry)
            RETURN .T.
         ELSE
            ::WriteLog("TA local expirado. Fecha expiración: " + DTOC(::dTokenExpiry) + " "+::cTokenTimeExpiry)

            FERASE(cTAFilename)
         ENDIF
      ENDIF
   ENDIF


   ::WriteLog("Generando TRA para servicio " + cService)


   cTRA := ::GenerarTRA(cService)
   IF EMPTY(cTRA)
      ::cLastError := "Error al generar TRA"
      ::nLastCode := 1001
      RETURN .F.
   ENDIF


   ::WriteLog("Firmando TRA con certificado " + cCertFile)
   cTraFirmado := ::FirmarTRA(cTRA, cCertFile, cPrivKeyFile)
   IF EMPTY(cTraFirmado)
      ::cLastError := "Error al firmar TRA"
      ::nLastCode := 1002
      RETURN .F.
   ENDIF


   cTraFirmadoBase64 := ::Base64Encode1(cTraFirmado)


   ::WriteLog("Enviando TRA a WSAA")
   cLoginTicketResponse := ::EnviarTRA(cTraFirmadoBase64)

   IF !EMPTY(cLoginTicketResponse)

      IF AT("coe.alreadyAuthenticated", cLoginTicketResponse) > 0
         ::WriteLog("Ya existe un TA válido para este servicio según WSAA")




         IF ::BuscarTAExistente(cService)
            ::WriteLog("Se ha recuperado un TA existente")
            RETURN .T.
         ENDIF



         ::WriteLog("No se pudo encontrar el TA existente. Generando uno nuevo con otro servicio...")



         RETURN ::Login(cCertFile, cPrivKeyFile, cService + "_alt")
      ENDIF


      lSuccess := ::ParseLoginTicketResponse(cLoginTicketResponse)

      IF lSuccess
         ::WriteLog("Login exitoso. Token obtenido con vencimiento " + DTOC(::dTokenExpiry))













         cTA := "<loginTicketResponse>" +  "<header>" +  "<expirationTime>" + SUBSTR(DTOS(::dTokenExpiry), 1, 4) + "-" +  SUBSTR(DTOS(::dTokenExpiry), 5, 2) + "-" +  SUBSTR(DTOS(::dTokenExpiry), 7, 2) +  "T"+::cTokenTimeExpiry+".000-03:00</expirationTime>" +  "</header>" +  "<credentials>" +  "<token>" + ::cToken + "</token>" +  "<sign>" + ::cSign + "</sign>" +  "</credentials>" +  "</loginTicketResponse>"

         MemoWrit2(cTAFilename, cTA)
         ::WriteLog("TA guardado en archivo: " + cTAFilename)
      ELSE
         ::WriteLog("Error al procesar respuesta de login: " + ::cLastError)
      ENDIF
   ELSE
      ::cLastError := "Error al enviar solicitud de login"
      ::nLastCode := 1003
      ::WriteLog("Error al enviar solicitud de login")
   ENDIF

RETURN lSuccess

static FUNCTION WSAFip_BuscarTAExistente( cService ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cTAFilename := "TA_" + cService + ".xml"
   LOCAL cTAAlternativeFilename := "TA_" + cService + "*.xml"
   LOCAL cFileName, aFiles := DIRECTORY(cTAAlternativeFilename)
   LOCAL cTA, cExpiration, cExpYear, cExpMonth, cExpDay
   LOCAL lFound := .F.

   ::WriteLog("Buscando TA existente para el servicio " + cService)


   FOR EACH cFileName IN aFiles
      cTA := MemoRead(cFileName[1])



      IF AT("<service>" + cService + "</service>", cTA) > 0 .OR.  AT("<service>" + cService, cTA) > 0


         IF AT("<token>", cTA) > 0
            ::cToken := SUBSTR(cTA, AT("<token>", cTA) + 7, AT("</token>", cTA) - AT("<token>", cTA) - 7)
         ENDIF

         IF AT("<sign>", cTA) > 0
            ::cSign := SUBSTR(cTA, AT("<sign>", cTA) + 6, AT("</sign>", cTA) - AT("<sign>", cTA) - 6)
         ENDIF

         IF AT("<expirationTime>", cTA) > 0
            cExpiration := SUBSTR(cTA, AT("<expirationTime>", cTA) + 16, AT("</expirationTime>", cTA) - AT("<expirationTime>", cTA) - 16)


            cExpYear := LEFT(cExpiration, 4)
            cExpMonth := SUBSTR(cExpiration, 6, 2)
            cExpDay := SUBSTR(cExpiration, 9, 2)

            ::dTokenExpiry := CTOD(cExpDay + "/" + cExpMonth + "/" + cExpYear)
            ::cTokenTimeExpiry := SUBSTR(cExpiration,12,8)
         ENDIF


         IF !EMPTY(::cToken) .AND. !EMPTY(::cSign) .AND. !EMPTY(::dTokenExpiry)
            IF ::dTokenExpiry > DATE() .OR. (::dTokenExpiry = DATE() .AND. ::cTokenTimeExpiry > TIME())
               ::WriteLog("TA válido encontrado en archivo alternativo: " + cFileName[1])


               MemoWrit2(cTAFilename, cTA)
               ::WriteLog("TA copiado a archivo estándar: " + cTAFilename)

               lFound := .T.
               EXIT
            ENDIF
         ENDIF
      ENDIF
   NEXT



   IF !lFound
      ::WriteLog("No se encontró ningún TA válido para el servicio " + cService)


      MemoWrit2(cTAFilename + ".notfound", DTOC(DATE()) + " " + TIME())
   ENDIF

RETURN lFound







static FUNCTION WSAFip_SFRecuperaLastCMP( nPuntoVta, nTipoComp ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse, cNroComp, cErrorMsg, cErrorCode
   LOCAL nUltimo := -1


   IF EMPTY(::cToken) .OR. EMPTY(::cSign)
      IF !::CheckTAExpired()

      ELSE
         ::cLastError := "Se requiere login para obtener Token y Sign"
         ::nLastCode := 1004
         ::WriteLog("Se requiere login para obtener Token y Sign")
         RETURN 0
      ENDIF
   ENDIF

   ::WriteLog("Consulta de último comprobante - Pto.Vta: " + ALLTRIM(STR(nPuntoVta)) + ", Tipo: " + ALLTRIM(STR(nTipoComp)))















   cXML := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ar="http://ar.gov.afip.dif.FEV1/">' +  "<soapenv:Header/>" +  "<soapenv:Body>" +  "<ar:FECompUltimoAutorizado>" +  "<ar:Auth>" +  "<ar:Token>" + ::XMLEncode(::cToken) + "</ar:Token>" +  "<ar:Sign>" + ::XMLEncode(::cSign) + "</ar:Sign>" +  "<ar:Cuit>" + ALLTRIM(::cCuitRepresentada) + "</ar:Cuit>" +  "</ar:Auth>" +  "<ar:PtoVta>" + ALLTRIM(STR(nPuntoVta)) + "</ar:PtoVta>" +  "<ar:CbteTipo>" + ALLTRIM(STR(nTipoComp)) + "</ar:CbteTipo>" +  "</ar:FECompUltimoAutorizado>" +  "</soapenv:Body>" +  "</soapenv:Envelope>"


   cResponse := ::SendRequest(::cUrlWsfe, "http://ar.gov.afip.dif.FEV1/FECompUltimoAutorizado", cXML)

   IF !EMPTY(cResponse)


      cNroComp := SUBSTR(cResponse, AT("<CbteNro>", cResponse) + 9, AT("</CbteNro>", cResponse) - AT("<CbteNro>", cResponse) - 9)

      IF !EMPTY(cNroComp)
         nUltimo := VAL(cNroComp)
         ::WriteLog("Último comprobante recuperado: " + ALLTRIM(STR(nUltimo)))
      ELSE

         IF AT("<Errors>", cResponse) > 0

            cErrorMsg := SUBSTR(cResponse, AT("<Msg>", cResponse) + 5, AT("</Msg>", cResponse) - AT("<Msg>", cResponse) - 5)
            cErrorCode := SUBSTR(cResponse, AT("<Code>", cResponse) + 6, AT("</Code>", cResponse) - AT("<Code>", cResponse) - 6)

            ::cLastError := cErrorMsg
            ::nLastCode := VAL(cErrorCode)
            ::WriteLog("Error al recuperar último comprobante: " + ::cLastError + " (Código: " + cErrorCode + ")")
         ELSE
            ::cLastError := "Error desconocido al recuperar último comprobante"
            ::nLastCode := 1005
            ::WriteLog("Error desconocido al recuperar último comprobante")
         ENDIF
      ENDIF
   ELSE
      ::cLastError := "Error al enviar solicitud de último comprobante"
      ::nLastCode := 1006
      ::WriteLog("Error al enviar solicitud de último comprobante")
   ENDIF

RETURN nUltimo




static FUNCTION WSAFip_Reset( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   ::aCabeceraFE := {0, 0, 0}
   ::aDetallesFE := {}
   ::aIvaItems := {}
   ::aTributos := {}
   ::aCompAsociados := {}
   ::aActividades := {}

   ::cCAE := ""
   ::dCAEVto := CTOD("")
   ::cResultado := ""
   ::aErrors := {}
   ::aObservaciones := {}

   ::WriteLog("Reset completado - Datos de comprobante limpiados")
RETURN NIL



















static FUNCTION WSAFip_AgregaFactura( nTipoFac, nTipoDoc, nNroDoc, nFacturaNro, dFechaComp, nTotal, nNoGrav, nNeto, nExento, dFecDes, dFecHas, dFchVto, cMoneda, nCotiza, nConcepto, cMismaMoneda, nCondicionIVA ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL aDetalle := {}


   If( cMoneda == nil, cMoneda := "PES", ) ;
   If( nCotiza == nil, nCotiza := 1, ) ;
   If( nConcepto == nil, nConcepto := 1, ) ;
   If( nCondicionIVA == nil, nCondicionIVA := 5, ) ;
   If( dFechaComp == nil, dFechaComp := DTOS(DATE()), ) ;
   If( cMismaMoneda == nil, cMismaMoneda := "N", ) ;


   ::aDetallesFE := {}


   ::aCabeceraFE[1] := 1
   ::aCabeceraFE[2] := nTipoFac






















   aDetalle := { nConcepto, nTipoDoc, nNroDoc, nFacturaNro, nFacturaNro, ::DateToWSDate(dFechaComp) , nTotal, nNoGrav, nNeto, nExento, 0, 0, ::DateToWSDate(dFecDes), ::DateToWSDate(dFecHas), ::DateToWSDate(dFchVto), cMoneda, nCotiza, cMismaMoneda, nCondicionIVA }

   AADD(::aDetallesFE, aDetalle)
   ::WriteLog("Factura agregada - Tipo: " + ALLTRIM(STR(nTipoFac)) + ", Nro: " + ALLTRIM(STR(nFacturaNro)) + ", Total: " + ALLTRIM(STR(nTotal)))

RETURN .T.










static FUNCTION WSAFip_AgregaCompAsoc( nTipoComp, nPuntoVta, nComprAsoc, cCuit, dFechaComp ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL aCompAsoc := {}







   aCompAsoc := { nTipoComp, nPuntoVta, nComprAsoc, cCuit, ::DateToWSDate(dFechaComp) }

   AADD(::aCompAsociados, aCompAsoc)
   ::WriteLog("Comprobante asociado agregado - Tipo: " + ALLTRIM(STR(nTipoComp)) + ", Pto.Vta: " + ALLTRIM(STR(nPuntoVta)) + ", Nro: " + ALLTRIM(STR(nComprAsoc)))

RETURN .T.








static FUNCTION WSAFip_AgregaIVA( nTasa, nNeto, nIva ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL aIvaItem := {}





   aIvaItem := { nTasa, nNeto, nIva }

   AADD(::aIvaItems, aIvaItem)
   ::WriteLog("Ítem IVA agregado - Tasa: " + ALLTRIM(STR(nTasa)) + ", Base: " + ALLTRIM(STR(nNeto)) + ", Importe: " + ALLTRIM(STR(nIva)))

RETURN .T.










static FUNCTION WSAFip_AgregaTributo( nCodigo, cDetalle, nBaseImp, nCoef, nImporte ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL aTributo := {}







   aTributo := { nCodigo, cDetalle, nBaseImp, nCoef, nImporte }

   AADD(::aTributos, aTributo)
   ::WriteLog("Tributo agregado - Código: " + ALLTRIM(STR(nCodigo)) + ", Detalle: " + cDetalle + ", Importe: " + ALLTRIM(STR(nImporte)))

RETURN .T.






static FUNCTION WSAFip_AgregaActividad( nCodigo ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   AADD(::aActividades, nCodigo)
   ::WriteLog("Actividad agregada - Código: " + ALLTRIM(STR(nCodigo)))

RETURN .T.







static FUNCTION WSAFip_agregaOpcional( cCodigo,cDetalle ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   AADD(::aOpcionales, {alltrim(cCodigo),ALLTRIM(cDetalle)} )
   ::WriteLog("Opcional agregado - Código: " + ALLTRIM(cCodigo))

RETURN .T.







static FUNCTION WSAFip_Autorizar( nPuntoVta, nTipoComp ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL lSuccess := .F.


   IF EMPTY(::cToken) .OR. EMPTY(::cSign)
      IF !::CheckTAExpired()

      ELSE
         ::cLastError := "Se requiere login para obtener Token y Sign"
         ::nLastCode  := 1016
         ::WriteLog("Se requiere login para obtener Token y Sign")
         RETURN .F.
      ENDIF
   ENDIF


   IF LEN(::aDetallesFE) == 0
      ::cLastError := "No hay datos de factura para autorizar"
      ::nLastCode  := 1017
      ::WriteLog("No hay datos de factura para autorizar")
      RETURN .F.
   ENDIF


   ::aCabeceraFE[3] := nPuntoVta


   IF ::aCabeceraFE[2] <> nTipoComp
      ::cLastError := "El tipo de comprobante no coincide con el cargado"
      ::nLastCode  := 1018
      ::WriteLog("El tipo de comprobante no coincide: Cargado=" + ALLTRIM(STR(::aCabeceraFE[2])) + ", Solicitado=" + ALLTRIM(STR(nTipoComp)))
      RETURN .F.
   ENDIF

   ::WriteLog("Iniciando autorización - Pto.Vta: " + ALLTRIM(STR(nPuntoVta)) + ", Tipo: " + ALLTRIM(STR(nTipoComp)))


   cXML := ::GenerarXMLCAESolicitar()


   cResponse := ::SendRequest(::cUrlWsfe, "http://ar.gov.afip.dif.FEV1/FECAESolicitar", cXML)

   IF !EMPTY(cResponse)

      lSuccess := ::ParseFECAESolicitarResponse(cResponse)
   ELSE
      ::cLastError := "Error al enviar solicitud de autorización"
      ::nLastCode  := 1019
      ::WriteLog("Error al enviar solicitud de autorización")
   ENDIF

RETURN lSuccess








static FUNCTION WSAFip_ConsultaCAE( nPuntoVta, nTipoComp, nNumComp ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL lSuccess := .F., cFchVto, cErrorMsg, cErrorCode


   IF EMPTY(::cToken) .OR. EMPTY(::cSign)
      IF !::CheckTAExpired()

      ELSE
         ::cLastError := "Se requiere login para obtener Token y Sign"
         ::nLastCode  := 1020
         ::WriteLog("Se requiere login para obtener Token y Sign")
         RETURN .F.
      ENDIF
   ENDIF

   ::WriteLog("Consulta de comprobante - Pto.Vta: " + ALLTRIM(STR(nPuntoVta)) + ", Tipo: " + ALLTRIM(STR(nTipoComp)) + ", Nro: " + ALLTRIM(STR(nNumComp)))


















   cXML := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ar="http://ar.gov.afip.dif.FEV1/">' +  "<soapenv:Header/>" +  "<soapenv:Body>" +  "<ar:FECompConsultar>" +  "<ar:Auth>" +  "<ar:Token>" + ::XMLEncode(::cToken) + "</ar:Token>" +  "<ar:Sign>" + ::XMLEncode(::cSign) + "</ar:Sign>" +  "<ar:Cuit>" + ALLTRIM(::cCuitRepresentada) + "</ar:Cuit>" +  "</ar:Auth>" +  "<ar:FeCompConsReq>" +  "<ar:CbteTipo>" + ALLTRIM(STR(nTipoComp)) + "</ar:CbteTipo>" +  "<ar:CbteNro>" + ALLTRIM(STR(nNumComp)) + "</ar:CbteNro>" +  "<ar:PtoVta>" + ALLTRIM(STR(nPuntoVta)) + "</ar:PtoVta>" +  "</ar:FeCompConsReq>" +  "</ar:FECompConsultar>" +  "</soapenv:Body>" +  "</soapenv:Envelope>"


   cResponse := ::SendRequest(::cUrlWsfe, "http://ar.gov.afip.dif.FEV1/FECompConsultar", cXML)

   IF !EMPTY(cResponse)

      ::Reset()


      IF AT("<CAE>", cResponse) > 0
         ::cCAE := SUBSTR(cResponse, AT("<CAE>", cResponse) + 5, AT("</CAE>", cResponse) - AT("<CAE>", cResponse) - 5)
         ::cResultado := SUBSTR(cResponse, AT("<Resultado>", cResponse) + 11, AT("</Resultado>", cResponse) - AT("<Resultado>", cResponse) - 11)

         cFchVto := SUBSTR(cResponse, AT("<FchVto>", cResponse) + 8, AT("</FchVto>", cResponse) - AT("<FchVto>", cResponse) - 8)
         IF !EMPTY(cFchVto)
            ::dCAEVto := STOD(SUBSTR(cFchVto, 1, 4) + SUBSTR(cFchVto, 5, 2) + SUBSTR(cFchVto, 7, 2))
         ENDIF

         ::WriteLog("Consulta exitosa - CAE: " + ::cCAE + ", Resultado: " + ::cResultado)
         lSuccess := .T.
      ELSE

         IF AT("<Errors>", cResponse) > 0

            cErrorMsg := SUBSTR(cResponse, AT("<Msg>", cResponse) + 5, AT("</Msg>", cResponse) - AT("<Msg>", cResponse) - 5)
            cErrorCode := SUBSTR(cResponse, AT("<Code>", cResponse) + 6, AT("</Code>", cResponse) - AT("<Code>", cResponse) - 6)

            ::cLastError := cErrorMsg
            ::nLastCode := VAL(cErrorCode)
            ::WriteLog("Error en consulta de comprobante: " + ::cLastError + " (Código: " + cErrorCode + ")")
         ELSE
            ::cLastError := "Error desconocido en consulta de comprobante"
            ::nLastCode := 1021
            ::WriteLog("Error desconocido en consulta de comprobante")
         ENDIF
      ENDIF
   ELSE
      ::cLastError := "Error al enviar solicitud de consulta de comprobante"
      ::nLastCode := 1022
      ::WriteLog("Error al enviar solicitud de consulta de comprobante")
   ENDIF

RETURN lSuccess





static FUNCTION WSAFip_GetTiposComprobantes( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL aTipos := {}, nPos, nIniTag, nFinTag, cTipoData, cId, cDesc


   IF EMPTY(::cToken) .OR. EMPTY(::cSign)
      IF !::CheckTAExpired()

      ELSE
         ::cLastError := "Se requiere login para obtener Token y Sign"
         ::nLastCode := 1023
         ::WriteLog("Se requiere login para obtener Token y Sign")
         RETURN NIL
      ENDIF
   ENDIF













   cXML := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ar="http://ar.gov.afip.dif.FEV1/">' +  "<soapenv:Header/>" +  "<soapenv:Body>" +  "<ar:FEParamGetTiposCbte>" +  "<ar:Auth>" +  "<ar:Token>" + ::XMLEncode(::cToken) + "</ar:Token>" +  "<ar:Sign>" + ::XMLEncode(::cSign) + "</ar:Sign>" +  "<ar:Cuit>" + ALLTRIM(::cCuitRepresentada) + "</ar:Cuit>" +  "</ar:Auth>" +  "</ar:FEParamGetTiposCbte>" +  "</soapenv:Body>" +  "</soapenv:Envelope>"


   cResponse := ::SendRequest(::cUrlWsfe, "http://ar.gov.afip.dif.FEV1/FEParamGetTiposCbte", cXML)

   IF !EMPTY(cResponse)





      nPos := 1
      while .T.
         nIniTag := AT("<CbteTipo>", SUBSTR(cResponse, nPos))
         IF nIniTag == 0
            EXIT
         ENDIF

         nIniTag := nPos + nIniTag - 1
         nFinTag := AT("</CbteTipo>", SUBSTR(cResponse, nIniTag)) + nIniTag + 10

         cTipoData := SUBSTR(cResponse, nIniTag, nFinTag - nIniTag)

         cId := SUBSTR(cTipoData, AT("<Id>", cTipoData) + 4, AT("</Id>", cTipoData) - AT("<Id>", cTipoData) - 4)
         cDesc := SUBSTR(cTipoData, AT("<Desc>", cTipoData) + 6, AT("</Desc>", cTipoData) - AT("<Desc>", cTipoData) - 6)

         AADD(aTipos, {VAL(cId), cDesc})

         nPos := nFinTag
      ENDDO

      ::WriteLog("Obtenidos " + ALLTRIM(STR(LEN(aTipos))) + " tipos de comprobantes")
   ELSE
      ::cLastError := "Error al obtener tipos de comprobantes"
      ::nLastCode := 1024
      ::WriteLog("Error al obtener tipos de comprobantes")
      RETURN NIL
   ENDIF

RETURN aTipos





static FUNCTION WSAFip_GetTiposDocumentos( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL aTipos := {}


   IF EMPTY(::cToken) .OR. EMPTY(::cSign)
      IF !::CheckTAExpired()

      ELSE
         ::cLastError := "Se requiere login para obtener Token y Sign"
         ::nLastCode := 1025
         ::WriteLog("Se requiere login para obtener Token y Sign")
         RETURN NIL
      ENDIF
   ENDIF













   cXML := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ar="http://ar.gov.afip.dif.FEV1/">' +  "<soapenv:Header/>" +  "<soapenv:Body>" +  "<ar:FEParamGetTiposDoc>" +  "<ar:Auth>" +  "<ar:Token>" + ::XMLEncode(::cToken) + "</ar:Token>" +  "<ar:Sign>" + ::XMLEncode(::cSign) + "</ar:Sign>" +  "<ar:Cuit>" + ALLTRIM(::cCuitRepresentada) + "</ar:Cuit>" +  "</ar:Auth>" +  "</ar:FEParamGetTiposDoc>" +  "</soapenv:Body>" +  "</soapenv:Envelope>"


   cResponse := ::SendRequest(::cUrlWsfe, "http://ar.gov.afip.dif.FEV1/FEParamGetTiposDoc", cXML)




RETURN aTipos





static FUNCTION WSAFip_GetTiposIva( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL aTipos := {}


   IF EMPTY(::cToken) .OR. EMPTY(::cSign)
      IF !::CheckTAExpired()

      ELSE
         ::cLastError := "Se requiere login para obtener Token y Sign"
         ::nLastCode := 1026
         ::WriteLog("Se requiere login para obtener Token y Sign")
         RETURN NIL
      ENDIF
   ENDIF













   cXML := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ar="http://ar.gov.afip.dif.FEV1/">' +  "<soapenv:Header/>" +  "<soapenv:Body>" +  "<ar:FEParamGetTiposIva>" +  "<ar:Auth>" +  "<ar:Token>" + ::XMLEncode(::cToken) + "</ar:Token>" +  "<ar:Sign>" + ::XMLEncode(::cSign) + "</ar:Sign>" +  "<ar:Cuit>" + ALLTRIM(::cCuitRepresentada) + "</ar:Cuit>" +  "</ar:Auth>" +  "</ar:FEParamGetTiposIva>" +  "</soapenv:Body>" +  "</soapenv:Envelope>"



RETURN aTipos





static FUNCTION WSAFip_GetTiposMonedas( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL aTipos := {}



RETURN aTipos





static FUNCTION WSAFip_GetTiposTributos( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL aTipos := {}



RETURN aTipos





static FUNCTION WSAFip_GetPuntosVenta( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL aPuntos := {}



RETURN aPuntos





static FUNCTION WSAFip_GetActividades( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL aActividades := {}



RETURN aActividades






static FUNCTION WSAFip_GetCondicionesIvaReceptor( cClaseComp ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse
   LOCAL aCondiciones := {}


   IF EMPTY(::cToken) .OR. EMPTY(::cSign)
      IF !::CheckTAExpired()

      ELSE
         ::cLastError := "Se requiere login para obtener Token y Sign"
         ::nLastCode := 1027
         ::WriteLog("Se requiere login para obtener Token y Sign")
         RETURN NIL
      ENDIF
   ENDIF














   cXML := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ar="http://ar.gov.afip.dif.FEV1/">' +  "<soapenv:Header/>" +  "<soapenv:Body>" +  "<ar:FEParamGetCondicionIvaReceptor>" +  "<ar:Auth>" +  "<ar:Token>" + ::XMLEncode(::cToken) + "</ar:Token>" +  "<ar:Sign>" + ::XMLEncode(::cSign) + "</ar:Sign>" +  "<ar:Cuit>" + ALLTRIM(::cCuitRepresentada) + "</ar:Cuit>" +  "</ar:Auth>" +  "<ar:ClaseCmp>" + cClaseComp + "</ar:ClaseCmp>" +  "</ar:FEParamGetCondicionIvaReceptor>" +  "</soapenv:Body>" +  "</soapenv:Envelope>"



RETURN aCondiciones




static FUNCTION WSAFip_GetLastError( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
RETURN ::cLastError

static FUNCTION WSAFip_GetLastErrorCode( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
RETURN ::nLastCode

static FUNCTION WSAFip_GetCAE( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
RETURN ::cCAE

static FUNCTION WSAFip_GetCAEVto( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
RETURN ::dCAEVto

static FUNCTION WSAFip_GetResultado( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
RETURN ::cResultado





static FUNCTION WSAFip_WriteLog( cMsg ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL nHandle, cTimeStamp
   IF ::lLogWrite
      cTimeStamp := DTOC(DATE()) + " " + TIME()

      nHandle := FOPEN(::cLogFile, 1)
      IF nHandle < 0
         nHandle := FCREATE(::cLogFile)
      ELSE
         FSEEK(nHandle, 0, 2)
      ENDIF

      IF nHandle >= 0
         FWRITE(nHandle, cTimeStamp + " - " + cMsg + Chr(13)+Chr(10))
         FCLOSE(nHandle)
      ENDIF
   ENDIF

RETURN NIL





static FUNCTION WSAFip_CheckTAExpired( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL lExpired := .T.

   IF !EMPTY(::cToken) .AND. !EMPTY(::cSign) .AND. !EMPTY(::dTokenExpiry)
      IF DATE() < ::dTokenExpiry
         lExpired := .F.
      ENDIF
   ENDIF

RETURN lExpired






static FUNCTION WSAFip_GenerarTRA( cService ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cTRA := ""
   LOCAL cUniqueId, cGenerationTime, cExpirationTime
   LOCAL aServerTime, dNow, cNowTime, dExp, cExpTime, nExpirationHours := 10
   LOCAL nHour, nMin, nSec


   cUniqueId := ALLTRIM(STR(INT(SECONDS() * 100)))


   aServerTime := ::GetAFIPServerTime()
   dNow := aServerTime[1]
   cNowTime := aServerTime[2]


   nHour := VAL(SUBSTR(cNowTime, 1, 2))
   nMin := VAL(SUBSTR(cNowTime, 4, 2))
   nSec := VAL(SUBSTR(cNowTime, 7, 2))



   nMin := nMin - 2
   IF nMin < 0
      nMin := nMin + 60
      nHour := nHour - 1
      IF nHour < 0
         nHour := nHour + 24
         dNow := dNow - 1
      ENDIF
   ENDIF




   cNowTime := PADL(ALLTRIM(STR(nHour)), 2, "0") + ":" +  PADL(ALLTRIM(STR(nMin)), 2, "0") + ":" +  PADL(ALLTRIM(STR(nSec)), 2, "0")



   nHour := nHour + nExpirationHours


   IF nHour >= 24
      nHour := nHour - 24
      dExp := dNow + 1
   ELSE
      dExp := dNow
   ENDIF




   cExpTime := PADL(ALLTRIM(STR(nHour)), 2, "0") + ":" +  PADL(ALLTRIM(STR(nMin)), 2, "0") + ":" +  PADL(ALLTRIM(STR(nSec)), 2, "0")






   cGenerationTime := SUBSTR(DTOS(dNow), 1, 4) + "-" +  SUBSTR(DTOS(dNow), 5, 2) + "-" +  SUBSTR(DTOS(dNow), 7, 2) + "T" +  cNowTime + ".000-03:00"




   cExpirationTime := SUBSTR(DTOS(dExp), 1, 4) + "-" +  SUBSTR(DTOS(dExp), 5, 2) + "-" +  SUBSTR(DTOS(dExp), 7, 2) + "T" +  cExpTime + ".000-03:00"

   ::WriteLog("TRA generado con - Generation Time: " + cGenerationTime)
   ::WriteLog("TRA generado con - Expiration Time: " + cExpirationTime)










   cTRA := '<?xml version="1.0" encoding="UTF-8"?>' +  '<loginTicketRequest version="1.0">' +  "<header>" +  "<uniqueId>" + cUniqueId + "</uniqueId>" +  "<generationTime>" + cGenerationTime + "</generationTime>" +  "<expirationTime>" + cExpirationTime + "</expirationTime>" +  "</header>" +  "<service>" + cService + "</service>" +  "</loginTicketRequest>"

RETURN cTRA





static FUNCTION WSAFip_GetAFIPServerTime( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cResponse := "", oXMLHTTP, oError
   LOCAL dServerDate := DATE()
   LOCAL cServerTime := TIME()
   LOCAL cDateHeader, aMonths, nMonth, cDay, cMonthStr, cYear, cTime
   LOCAL nHour, nMin, nSec

   ::WriteLog("Obteniendo fecha y hora del servidor AFIP...")


   aMonths := {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }

      oXMLHTTP := CreateObject("MSXML2.XMLHTTP")


      IF ::cUrlWsfe == "https://wswhomo.afip.gov.ar/wsfev1/service.asmx"

         oXMLHTTP:Open("HEAD", "https://wswhomo.afip.gov.ar/wsfev1/service.asmx", .F.)
      ELSE

         oXMLHTTP:Open("HEAD", "https://servicios1.afip.gov.ar/wsfev1/service.asmx", .F.)
      ENDIF

      oXMLHTTP:Send()


      cDateHeader := oXMLHTTP:GetResponseHeader("Date")
      ::WriteLog("Header de fecha obtenido: " + cDateHeader)



      IF !EMPTY(cDateHeader)

         cDay := ALLTRIM(SUBSTR(cDateHeader, AT(",", cDateHeader) + 2, 2))
         cMonthStr := ALLTRIM(SUBSTR(cDateHeader, AT(",", cDateHeader) + 5, 3))
         cYear := ALLTRIM(SUBSTR(cDateHeader, AT(" " + cMonthStr + " ", cDateHeader) + 5, 4))
         cTime := ALLTRIM(SUBSTR(cDateHeader, AT(cYear, cDateHeader) + 5, 8))


         nMonth := 0
         FOR nMonth := 1 TO 12
            IF cMonthStr == aMonths[nMonth]
               EXIT
            ENDIF
         NEXT


         dServerDate := CTOD(cDay + "/" + PADL(ALLTRIM(STR(nMonth)), 2, "0") + "/" + cYear)


         nHour := VAL(SUBSTR(cTime, 1, 2))
         nMin := VAL(SUBSTR(cTime, 4, 2))
         nSec := VAL(SUBSTR(cTime, 7, 2))


         nHour := nHour - 3

         IF nHour < 0
            nHour := nHour + 24
            dServerDate := dServerDate - 1
         ENDIF




         cServerTime := PADL(ALLTRIM(STR(nHour)), 2, "0") + ":" +  PADL(ALLTRIM(STR(nMin)), 2, "0") + ":" +  PADL(ALLTRIM(STR(nSec)), 2, "0")

         ::WriteLog("Fecha del servidor AFIP convertida: " + DTOC(dServerDate) + " " + cServerTime)
      ELSE
         ::WriteLog("No se pudo obtener el header de fecha. Usando fecha y hora local.")
      ENDIF

   RECOVER USING oError
      ::cLastError := "Error al obtener la hora del servidor: " + oError:Description
      ::nLastCode := 1090
      ::WriteLog(::cLastError)
      ::WriteLog("Usando fecha y hora local como alternativa.")
   END


   oXMLHTTP := NIL

RETURN {dServerDate, cServerTime}








static FUNCTION WSAFip_FirmarTRA( cTRA, cCertFile, cPrivKeyFile ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cTraFirmado := ""
   LOCAL cComando


   MemoWrit2("tra_temp.xml", cTRA)
   ::WriteLog("TRA guardado en tra_temp.xml para firmar")









   cComando := ::cPathOpenSSL+"\openssl cms -sign -in tra_temp.xml -signer "+cCertFile+" "+ " -inkey "+cPrivKeyFile+" -outform DER -out tra_signed.cms -nodetach -binary"

   ::WriteLog("Ejecutando comando: " + cComando)


   WaitRun(cComando, 0)


   IF FILE("tra_signed.cms")
      ::WriteLog("Archivo tra_signed.cms generado correctamente")
      cTraFirmado := MemoRead("tra_signed.cms")
      ::WriteLog("Tamaño del archivo firmado: " + ALLTRIM(STR(LEN(cTraFirmado))) + " bytes")
   ELSE
      ::cLastError := "Error al firmar TRA con OpenSSL: El archivo tra_signed.cms no fue generado"
      ::nLastCode := 1010
      ::WriteLog("Error al firmar TRA con OpenSSL: El archivo tra_signed.cms no fue generado")
   ENDIF

RETURN cTraFirmado






static FUNCTION WSAFip_EnviarTRA( cTraFirmadoBase64 ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML, cResponse


   IF EMPTY(cTraFirmadoBase64)
      ::cLastError := "No hay datos CMS válidos para enviar"
      ::nLastCode := 1080
      ::WriteLog("Error: No hay datos CMS válidos para enviar")
      RETURN ""
   ENDIF

   ::WriteLog("Tamaño del CMS codificado en Base64: " + ALLTRIM(STR(LEN(cTraFirmadoBase64))) + " bytes")


   IF LEN(cTraFirmadoBase64) < 100
      ::cLastError := "El CMS codificado parece demasiado corto o vacío"
      ::nLastCode := 1060
      ::WriteLog("Error: El CMS codificado parece demasiado corto o vacío")
      RETURN ""
   ENDIF



   ::WriteLog("CMS codificado guardado en cms_base64.txt para verificación")









   cXML := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:wsaa="http://wsaa.view.sua.dvadac.desein.afip.gov">' +  "<soapenv:Header/>" +  "<soapenv:Body>" +  "<wsaa:loginCms>" +  "<wsaa:in0>" + cTraFirmadoBase64 + "</wsaa:in0>" +  "</wsaa:loginCms>" +  "</soapenv:Body>" +  "</soapenv:Envelope>"





   cResponse := ::SendRequest(::cUrlWsaa, "http://wsaa.view.sua.dvadac.desein.afip.gov/loginCms", cXML)


   IF !EMPTY(cResponse)



      cResponse := STRTRAN(cResponse, "&lt;", "<")
      cResponse := STRTRAN(cResponse, "&gt;", ">")
      cResponse := STRTRAN(cResponse, "&quot;", '"')
      cResponse := STRTRAN(cResponse, "&apos;", "'")
      cResponse := STRTRAN(cResponse, "&amp;", "&")



   ENDIF

RETURN cResponse






static FUNCTION WSAFip_ParseLoginTicketResponse( cResponse ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL lSuccess := .F.
   LOCAL cToken, cSign, cExpiration
   LOCAL cCdata, cLoginCmsReturn, cErrorMsg, nStart, nEnd, cExpYear, cExpMonth, cExpDay, cExpTime



   ::WriteLog("Respuesta completa guardada en login_response_full.xml")


   ::WriteLog("Analizando respuesta para extraer credenciales...")


   IF AT("<faultstring>", cResponse) > 0
      cErrorMsg := SUBSTR(cResponse, AT("<faultstring>", cResponse) + 13, AT("</faultstring>", cResponse) - AT("<faultstring>", cResponse) - 13)
      ::WriteLog("Error reportado por AFIP: " + cErrorMsg)
      ::cLastError := cErrorMsg
      ::nLastCode := 1099
      RETURN .F.
   ENDIF


   cLoginCmsReturn := ""
   IF AT("<loginCmsReturn>", cResponse) > 0 .AND. AT("</loginCmsReturn>", cResponse) > 0
      nStart := AT("<loginCmsReturn>", cResponse) + 16
      nEnd := AT("</loginCmsReturn>", cResponse)
      cLoginCmsReturn := SUBSTR(cResponse, nStart, nEnd - nStart)
      ::WriteLog("Contenido de loginCmsReturn extraído, longitud: " + ALLTRIM(STR(LEN(cLoginCmsReturn))))
   ENDIF



   IF AT("<token>", cResponse) > 0 .AND. AT("</token>", cResponse) > 0
      nStart := AT("<token>", cResponse) + 7
      nEnd := AT("</token>", cResponse)
      ::cToken := SUBSTR(cResponse, nStart, nEnd - nStart)
      ::WriteLog("Token extraído, longitud: " + ALLTRIM(STR(LEN(::cToken))))
   ENDIF


   IF AT("<sign>", cResponse) > 0 .AND. AT("</sign>", cResponse) > 0
      nStart := AT("<sign>", cResponse) + 6
      nEnd := AT("</sign>", cResponse)
      ::cSign := SUBSTR(cResponse, nStart, nEnd - nStart)
      ::WriteLog("Sign extraído, longitud: " + ALLTRIM(STR(LEN(::cSign))))
   ENDIF


   IF AT("<expirationTime>", cResponse) > 0 .AND. AT("</expirationTime>", cResponse) > 0
      nStart := AT("<expirationTime>", cResponse) + 16
      nEnd := AT("</expirationTime>", cResponse)
      cExpiration := SUBSTR(cResponse, nStart, nEnd - nStart)
      ::WriteLog("Valor de expirationTime extraído: '" + cExpiration + "'")




      IF LEN(cExpiration) >= 10
         cExpiration := STRTRAN(cExpiration,">","")
         cExpYear := SUBSTR(cExpiration, 1, 4)
         cExpMonth := SUBSTR(cExpiration, 6, 2)
         cExpDay := SUBSTR(cExpiration, 9, 2)
         cExpTime := SUBSTR(cExpiration, 12, 8)

         ::WriteLog("Componentes de fecha: Año=" + cExpYear + ", Mes=" + cExpMonth + ", Día=" + cExpDay + " Hora:"+cExpTime)



         IF VAL(cExpYear) >= 2023 .AND. VAL(cExpMonth) >= 1 .AND. VAL(cExpMonth) <= 12 .AND.  VAL(cExpDay) >= 1 .AND. VAL(cExpDay) <= 31

            ::dTokenExpiry := CTOD(cExpDay + "/" + cExpMonth + "/" + cExpYear)
            ::cTokenTimeExpiry := cExpTime
            ::WriteLog("Fecha de expiración convertida: " + DTOC(::dTokenExpiry) + " "+::cTokenTimeExpiry)
         ELSE
            ::WriteLog("Error: Componentes de fecha inválidos")

            ::dTokenExpiry := DATE() + 1
            ::cTokenTimeExpiry := "00:00:00"
            ::WriteLog("Usando fecha alternativa: " + DTOC(::dTokenExpiry)+" "+::cTokenTimeExpiry)
         ENDIF
      ELSE
         ::WriteLog("Error: Formato de expirationTime inesperado - muy corto")

         ::dTokenExpiry := DATE() + 1
         ::cTokenTimeExpiry := "00:00:00"
         ::WriteLog("Usando fecha alternativa: " + DTOC(::dTokenExpiry) + " "+::cTokenTimeExpiry)
      ENDIF
   ELSE
      ::WriteLog("Error: No se encontró el elemento expirationTime")

      ::dTokenExpiry := DATE() + 1
      ::cTokenTimeExpiry := "00:00:00"
      ::WriteLog("Usando fecha alternativa: " + DTOC(::dTokenExpiry) + " "+ ::cTokenTimeExpiry)
   ENDIF


   IF !EMPTY(::cToken) .AND. !EMPTY(::cSign) .AND. !EMPTY(::dTokenExpiry)
      lSuccess := .T.
      ::WriteLog("Extracción de credenciales exitosa - Token, Sign y Fecha de Expiración obtenidos")
   ELSE
      ::cLastError := "Error al extraer credenciales del LoginTicketResponse"
      ::nLastCode := 1011
      ::WriteLog("Error al extraer credenciales del LoginTicketResponse")


      ::WriteLog("Contenido de la respuesta (resumen):")
      ::WriteLog("Longitud total: " + ALLTRIM(STR(LEN(cResponse))))


      IF LEN(cResponse) > 300
         ::WriteLog("Primeros 300 caracteres: " + LEFT(cResponse, 300))
      ELSE
         ::WriteLog("Contenido completo: " + cResponse)
      ENDIF
   ENDIF

RETURN lSuccess





static FUNCTION WSAFip_GenerarXMLCAESolicitar( ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cXML := ""
   LOCAL cDetalle := ""
   LOCAL aDetalle, cFecha, nImpIVA, nImpTrib
   LOCAL cIvaItems := ""
   LOCAL cTributos := ""
   LOCAL cCompAsoc := ""
   LOCAL cActividades := ""
   LOCAL cOpcionales := ""
   LOCAL nI


   IF LEN(::aDetallesFE) == 0
      RETURN ""
   ENDIF

   aDetalle := ::aDetallesFE[1]


   IF EMPTY(aDetalle[6])
      cFecha := DTOS(DATE())
      aDetalle[6] := cFecha
   ENDIF


   nImpIVA := 0
   FOR nI := 1 TO LEN(::aIvaItems)
      nImpIVA += ::aIvaItems[nI][3]
   NEXT
   aDetalle[12] := nImpIVA


   nImpTrib := 0
   FOR nI := 1 TO LEN(::aTributos)
      nImpTrib += ::aTributos[nI][5]
   NEXT
   aDetalle[11] := nImpTrib


   FOR nI := 1 TO LEN(::aIvaItems)




      cIvaItems += "<ar:AlicIva>" +  "<ar:Id>" + ALLTRIM(STR(::aIvaItems[nI][1])) + "</ar:Id>" +  "<ar:BaseImp>" + ALLTRIM(STR(::aIvaItems[nI][2], 15, 2)) + "</ar:BaseImp>" +  "<ar:Importe>" + ALLTRIM(STR(::aIvaItems[nI][3], 15, 2)) + "</ar:Importe>" +  "</ar:AlicIva>"
   NEXT


   FOR nI := 1 TO LEN(::aOpcionales)



      cOpcionales += "<ar:Opcional>" +  "<ar:Id>" + ALLTRIM(STR(::aIvaItems[nI][1])) + "</ar:Id>" +  "<ar:Valor>" + ALLTRIM(STR(::aIvaItems[nI][2], 15, 2)) + "</ar:Valor>" +  "</ar:Opcional>"
   NEXT



   FOR nI := 1 TO LEN(::aTributos)






      cTributos += "<ar:Tributo>" +  "<ar:Id>" + ALLTRIM(STR(::aTributos[nI][1])) + "</ar:Id>" +  "<ar:Desc>" + ::XMLEncode(::aTributos[nI][2]) + "</ar:Desc>" +  "<ar:BaseImp>" + ALLTRIM(STR(::aTributos[nI][3], 15, 2)) + "</ar:BaseImp>" +  "<ar:Alic>" + ALLTRIM(STR(::aTributos[nI][4], 5, 2)) + "</ar:Alic>" +  "<ar:Importe>" + ALLTRIM(STR(::aTributos[nI][5], 15, 2)) + "</ar:Importe>" +  "</ar:Tributo>"
   NEXT


   FOR nI := 1 TO LEN(::aCompAsociados)



      cCompAsoc += "<ar:CbteAsoc>" +  "<ar:Tipo>" + ALLTRIM(STR(::aCompAsociados[nI][1])) + "</ar:Tipo>" +  "<ar:PtoVta>" + ALLTRIM(STR(::aCompAsociados[nI][2])) + "</ar:PtoVta>" +  "<ar:Nro>" + ALLTRIM(STR(::aCompAsociados[nI][3])) + "</ar:Nro>"


      IF !EMPTY(::aCompAsociados[nI][4])
         cCompAsoc += "<ar:Cuit>" + ::aCompAsociados[nI][4] + "</ar:Cuit>"
      ENDIF


      IF !EMPTY(::aCompAsociados[nI][5])
         cCompAsoc += "<ar:CbteFch>" + ::aCompAsociados[nI][5] + "</ar:CbteFch>"
      ENDIF

      cCompAsoc += "</ar:CbteAsoc>"
   NEXT


   FOR nI := 1 TO LEN(::aActividades)


      cActividades += "<ar:Actividad>" +  "<ar:Id>" + ALLTRIM(STR(::aActividades[nI])) + "</ar:Id>" +  "</ar:Actividad>"
   NEXT






























   cXML := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ar="http://ar.gov.afip.dif.FEV1/">' +  "<soapenv:Header/>" +  "<soapenv:Body>" +  "<ar:FECAESolicitar>" +  "<ar:Auth>" +  "<ar:Token>" + ::XMLEncode(::cToken) + "</ar:Token>" +  "<ar:Sign>" + ::XMLEncode(::cSign) + "</ar:Sign>" +  "<ar:Cuit>" + ALLTRIM(::cCuitRepresentada) + "</ar:Cuit>" +  "</ar:Auth>" +  "<ar:FeCAEReq>" +  "<ar:FeCabReq>" +  "<ar:CantReg>" + ALLTRIM(STR(::aCabeceraFE[1])) + "</ar:CantReg>" +  "<ar:PtoVta>" + ALLTRIM(STR(::aCabeceraFE[3])) + "</ar:PtoVta>" +  "<ar:CbteTipo>" + ALLTRIM(STR(::aCabeceraFE[2])) + "</ar:CbteTipo>" +  "</ar:FeCabReq>" +  "<ar:FeDetReq>" +  "<ar:FECAEDetRequest>" +  "<ar:Concepto>" + ALLTRIM(STR(aDetalle[1])) + "</ar:Concepto>" +  "<ar:DocTipo>" + ALLTRIM(STR(aDetalle[2])) + "</ar:DocTipo>" +  "<ar:DocNro>" + ALLTRIM(STR(aDetalle[3])) + "</ar:DocNro>" +  "<ar:CbteDesde>" + ALLTRIM(STR(aDetalle[4])) + "</ar:CbteDesde>" +  "<ar:CbteHasta>" + ALLTRIM(STR(aDetalle[5])) + "</ar:CbteHasta>" +  "<ar:CbteFch>" + aDetalle[6] + "</ar:CbteFch>" +  "<ar:ImpTotal>" + ALLTRIM(STR(aDetalle[7], 15, 2)) + "</ar:ImpTotal>" +  "<ar:ImpTotConc>" + ALLTRIM(STR(aDetalle[8], 15, 2)) + "</ar:ImpTotConc>" +  "<ar:ImpNeto>" + ALLTRIM(STR(aDetalle[9], 15, 2)) + "</ar:ImpNeto>" +  "<ar:ImpOpEx>" + ALLTRIM(STR(aDetalle[10], 15, 2)) + "</ar:ImpOpEx>" +  "<ar:ImpTrib>" + ALLTRIM(STR(aDetalle[11], 15, 2)) + "</ar:ImpTrib>" +  "<ar:ImpIVA>" + ALLTRIM(STR(aDetalle[12], 15, 2)) + "</ar:ImpIVA>"


   IF !EMPTY(aDetalle[13])
      cXML += "<ar:FchServDesde>" + aDetalle[13] + "</ar:FchServDesde>"
   ENDIF

   IF !EMPTY(aDetalle[14])
      cXML += "<ar:FchServHasta>" + aDetalle[14] + "</ar:FchServHasta>"
   ENDIF

   IF !EMPTY(aDetalle[15])
      cXML += "<ar:FchVtoPago>" + aDetalle[15] + "</ar:FchVtoPago>"
   ENDIF





   cXML += "<ar:MonId>" + aDetalle[16] + "</ar:MonId>" +  "<ar:MonCotiz>" + ALLTRIM(STR(aDetalle[17], 16, 6)) + "</ar:MonCotiz>" +  "<ar:CanMisMonExt>"+ ALLTRIM(aDetalle[18])+ "</ar:CanMisMonExt>"+ "<ar:CondicionIVAReceptorId>" + ALLTRIM(STR(aDetalle[19])) + "</ar:CondicionIVAReceptorId>"


   IF !EMPTY(cCompAsoc)
      cXML += "<ar:CbtesAsoc>" + cCompAsoc + "</ar:CbtesAsoc>"
   ENDIF


   IF !EMPTY(cIvaItems)
      cXML += "<ar:Iva>" + cIvaItems + "</ar:Iva>"
   ENDIF


   IF !EMPTY(cOpcionales)
      cXML += "<ar:Opcionales>" + cOpcionales + "</ar:Opcionales>"
   ENDIF


   IF !EMPTY(cTributos)
      cXML += "<ar:Tributos>" + cTributos + "</ar:Tributos>"
   ENDIF


   IF !EMPTY(cActividades)
      cXML += "<ar:Actividades>" + cActividades + "</ar:Actividades>"
   ENDIF







   cXML += "</ar:FECAEDetRequest>" +  "</ar:FeDetReq>" +  "</ar:FeCAEReq>" +  "</ar:FECAESolicitar>" +  "</soapenv:Body>" +  "</soapenv:Envelope>"


RETURN cXML






static FUNCTION WSAFip_ParseFECAESolicitarResponse( cResponse ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL lSuccess := .F., nPos, nIniTag, nFinTag, cErrorData, cCode, cMsg, cObsData, cFchVto


   ::cCAE := ""
   ::dCAEVto := CTOD("")
   ::cResultado := ""
   ::aErrors := {}
   ::aObservaciones := {}


   IF AT("<Errors>", cResponse) > 0

      nPos := 1
      while .T.
         nIniTag := AT("<Err>", SUBSTR(cResponse, nPos))
         IF nIniTag == 0
            EXIT
         ENDIF

         nIniTag := nPos + nIniTag - 1
         nFinTag := AT("</Err>", SUBSTR(cResponse, nIniTag)) + nIniTag + 6

         cErrorData := SUBSTR(cResponse, nIniTag, nFinTag - nIniTag)

         cCode := SUBSTR(cErrorData, AT("<Code>", cErrorData) + 6, AT("</Code>", cErrorData) - AT("<Code>", cErrorData) - 6)
         cMsg := SUBSTR(cErrorData, AT("<Msg>", cErrorData) + 5, AT("</Msg>", cErrorData) - AT("<Msg>", cErrorData) - 5)

         AADD(::aErrors, {VAL(cCode), cMsg})

         nPos := nFinTag
      ENDDO

      IF LEN(::aErrors) > 0
         ::cLastError := ::aErrors[1, 2]
         ::nLastCode := ::aErrors[1, 1]
      ELSE
         ::cLastError := "Error desconocido en la solicitud de CAE"
         ::nLastCode := 1014
      ENDIF

      ::WriteLog("Error en solicitud de CAE: " + ::cLastError + " (Código: " + ALLTRIM(STR(::nLastCode)) + ")")
      RETURN .F.
   ENDIF


   IF AT("<Resultado>", cResponse) > 0
      ::cResultado := SUBSTR(cResponse, AT("<Resultado>", cResponse) + 11, AT("</Resultado>", cResponse) - AT("<Resultado>", cResponse) - 11)
   ENDIF


   IF AT("<CAE>", cResponse) > 0
      ::cCAE := SUBSTR(cResponse, AT("<CAE>", cResponse) + 5, AT("</CAE>", cResponse) - AT("<CAE>", cResponse) - 5)

      cFchVto := SUBSTR(cResponse, AT("<CAEFchVto>", cResponse) + 11, AT("</CAEFchVto>", cResponse) - AT("<CAEFchVto>", cResponse) - 11)
      IF !EMPTY(cFchVto)
         ::dCAEVto := STOD(SUBSTR(cFchVto, 1, 4) + SUBSTR(cFchVto, 5, 2) + SUBSTR(cFchVto, 7, 2))
      ENDIF


      IF AT("<Obs>", cResponse) > 0
         nPos := 1
         while .T.
            nIniTag := AT("<Observaciones>", SUBSTR(cResponse, nPos))
            IF nIniTag == 0
               EXIT
            ENDIF

            nIniTag := nPos + nIniTag - 1
            nFinTag := AT("</Observaciones>", SUBSTR(cResponse, nIniTag)) + nIniTag + 16

            cObsData := SUBSTR(cResponse, nIniTag, nFinTag - nIniTag)

            cCode := SUBSTR(cObsData, AT("<Code>", cObsData) + 6, AT("</Code>", cObsData) - AT("<Code>", cObsData) - 6)
            cMsg := SUBSTR(cObsData, AT("<Msg>", cObsData) + 5, AT("</Msg>", cObsData) - AT("<Msg>", cObsData) - 5)

            AADD(::aObservaciones, {VAL(cCode), cMsg})

            nPos := nFinTag
         ENDDO
      ENDIF

      lSuccess := .T.
      ::WriteLog("Solicitud de CAE exitosa: " + ::cCAE + ", Venc: " + DTOC(::dCAEVto))
   ELSE
      ::cLastError := "No se encontró CAE en la respuesta"
      ::nLastCode := 1015
      ::WriteLog("No se encontró CAE en la respuesta")
   ENDIF

RETURN lSuccess








static FUNCTION WSAFip_SendRequest( cURL, cAction, cXML ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cResponse := ""
   LOCAL oXMLHTTP, nStatus, oError


   ::WriteLog("Enviando solicitud a URL: " + cURL)
   ::WriteLog("SOAPAction: " + cAction)

   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }

      oXMLHTTP := CreateObject("MSXML2.XMLHTTP")


      oXMLHTTP:Open("POST", cURL, .F.)


      oXMLHTTP:SetRequestHeader("Content-Type", "text/xml; charset=utf-8")
      oXMLHTTP:SetRequestHeader("SOAPAction", cAction)


      oXMLHTTP:Send(cXML)


      nStatus := oXMLHTTP:Status

      IF nStatus == 200

          cResponse := oXMLHTTP:ResponseText
          ::WriteLog("Solicitud enviada con éxito. Estado: 200 OK")


      ELSE
         ::cLastError := "Error en la solicitud HTTP. Estado: " + ALLTRIM(STR(nStatus))
         ::nLastCode := nStatus
         ::WriteLog(::cLastError + " - " + oXMLHTTP:StatusText)
         ::WriteLog("Respuesta de error: " + oXMLHTTP:ResponseText)
      ENDIF

   RECOVER USING oError
      ::cLastError := "Error al enviar la solicitud: "+oError:Description
      ::nLastCode := oError:subcode
      ::WriteLog(::cLastError)
   END


   oXMLHTTP := NIL

RETURN cResponse
























static FUNCTION WSAFip_Base64Encode1( cData ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cEncoded := "", oError


   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }

      MemoWrit2("temp_bin.dat", cData)


      WaitRun(::cPathOpenSSL+"\openssl base64 -in temp_bin.dat -out temp_b64.dat", 0)


      IF FILE("temp_b64.dat")
         cEncoded := MemoRead("temp_b64.dat")
         cEncoded := STRTRAN(cEncoded, CHR(13), "")
         cEncoded := STRTRAN(cEncoded, CHR(10), "")
         ::WriteLog("Codificación Base64 exitosa. Tamaño: " + ALLTRIM(STR(LEN(cEncoded))) + " bytes")
      ELSE
         ::cLastError := "Error al codificar en Base64: No se pudo crear el archivo temp_b64.dat"
         ::nLastCode := 1070
         ::WriteLog(::cLastError)
      ENDIF


      IF FILE("temp_bin.dat")
         FERASE("temp_bin.dat")
      ENDIF
      IF FILE("temp_b64.dat")
         FERASE("temp_b64.dat")
      ENDIF

   RECOVER USING oError
      ::cLastError := "Error al codificar en Base64: " + oError:Description
      ::nLastCode := 1071
      ::WriteLog(::cLastError)
   END

RETURN cEncoded





static FUNCTION WSAFip_Base64Decode1( cData ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cDecoded := ""




   cDecoded := Base64Decode(cData)









RETURN cDecoded






static FUNCTION WSAFip_XMLEncode( cStr ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cResult := cStr

   cResult := STRTRAN(cResult, "&", "&amp;")
   cResult := STRTRAN(cResult, "<", "&lt;")
   cResult := STRTRAN(cResult, ">", "&gt;")
   cResult := STRTRAN(cResult, '"', "&quot;")
   cResult := STRTRAN(cResult, "'", "&apos;")

RETURN cResult






static FUNCTION WSAFip_DateToWSDate( dDate ) ; local Self AS CLASS WSAFip := QSelf() AS CLASS WSAFip
   LOCAL cDate := ""
   IF VALTYPE(dDate) = "C"
      cDate := dDate
      ELSE
      IF !EMPTY(dDate)
         cDate := DTOS(dDate)
      ENDIF
   ENDIF
RETURN cDate

static function MemoWrit2(cFile, cText)
LOCAL Han := FCreate(cFile), nBytes

nBytes := FWRITE(Han,cText,LEN(cText))
FClose(Han)
RETURN nil






STATIC FUNCTION  Base64Encode(cData)
   LOCAL cBase64Chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
   LOCAL cResult := "", nLen, nValue, nBits, nChar, nI
   LOCAL nPad := 0



   nLen := LEN(cData)


   IF MOD(nLen, 3) == 1
      nPad := 2
   ELSEIF MOD(nLen, 3) == 2
      nPad := 1
   ENDIF


   FOR nI := 1 TO nLen STEP 3

      nValue := ASC(SUBSTR(cData, nI, 1)) * 65536

      IF nI + 1 <= nLen
         nValue += ASC(SUBSTR(cData, nI + 1, 1)) * 256
      ENDIF

      IF nI + 2 <= nLen
         nValue += ASC(SUBSTR(cData, nI + 2, 1))
      ENDIF


      nBits := 18
      FOR nChar := 1 TO 4
         IF nI + (nChar - 1) / 1.33 <= nLen
            cResult += SUBSTR(cBase64Chars, INT(nValue / (2 ^ nBits)) % 64 + 1, 1)
         ELSE
            cResult += "="
         ENDIF
         nBits -= 6
      NEXT
   NEXT
RETURN cResult






STATIC FUNCTION Base64Decode(cData)
   LOCAL cBase64Chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
   LOCAL cResult := "", nLen, nValue, nPad, nI, nJ, nPos




   cData := STRTRAN(cData, CHR(13), "")
   cData := STRTRAN(cData, CHR(10), "")
   cData := STRTRAN(cData, " ", "")


   nPad := 0
   IF RIGHT(cData, 1) == "="
      nPad++
      cData := LEFT(cData, LEN(cData) - 1)
      IF RIGHT(cData, 1) == "="
         nPad++
         cData := LEFT(cData, LEN(cData) - 1)
      ENDIF
   ENDIF

   nLen := LEN(cData)


   FOR nI := 1 TO nLen STEP 4
      nValue := 0


      FOR nJ := 0 TO 3
         IF nI + nJ <= nLen
            nPos := AT(SUBSTR(cData, nI + nJ, 1), cBase64Chars) - 1
            IF nPos >= 0
               nValue := nValue * 64 + nPos
            ENDIF
         ENDIF
      NEXT


      cResult += CHR(INT(nValue / 65536) % 256)

      IF nI + 1 <= nLen - nPad
         cResult += CHR(INT(nValue / 256) % 256)
      ENDIF

      IF nI + 2 <= nLen - nPad
         cResult += CHR(nValue % 256)
      ENDIF
   NEXT
RETURN cResult
